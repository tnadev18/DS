# -*- coding: utf-8 -*-
"""ds_practical_02.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tE_Y6tbSHrtrLWy1XdgQu3Syx_NgdOzl
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
# %matplotlib inline

df = pd.read_csv('datasets/StudentsPerformance.csv')
df.head()

df.shape

# Data Description and other basic Info
df.describe()

df.isnull().sum()

df.isnull()

# Question 1

# If there are only a few missing values, we can choose to drop those rows
# df.dropna(inplace=True)

df.head()
df.shape
df.columns

# Alternatively, we can impute missing values using techniques like mean, median, or mode imputation
# For numeric columns, let's impute missing values with the mean
# For categorical columns, let's impute missing values with the mode (most frequent value)

# Example for numeric columns:
# df['math score'].fillna(df['math score'].mean(), inplace=True)

# Example for categorical columns:
df['math score'].fillna(df['math score'].mode().iloc[0], inplace=True)
df['reading score'].fillna(df['reading score'].mode().iloc[0], inplace=True)
df['writing score'].fillna(df['writing score'].mode().iloc[0], inplace=True)

df.head()
df.isnull().sum()
# df.shape

print("\nDataFrame after Handling Missing Values and Inconsistencies:")
print(df)

# Question 2

sns.boxplot(y=df['math score'])

sns.boxplot(y=df['reading score'])

sns.boxplot(y=df['writing score'])

# Step 1: Identify potential outliers
# For 'math score'
math_score = df['math score']
mean_m, std_dev_m, median_m = math_score.mean(), math_score.std(), math_score.median()
Q1_m, Q3_m = math_score.quantile(0.25), math_score.quantile(0.75)
IQR_m = Q3_m - Q1_m
lower_bound_m, upper_bound_m = Q1_m - 1.5 * IQR_m, Q3_m + 1.5 * IQR_m

# Print summary statistics for 'math score'
print("Math Score:")
print("Mean:", mean_m)
print("Standard Deviation:", std_dev_m)
print("Median:", median_m)
print("Lower Bound (1.5 * IQR):", lower_bound_m)
print("Upper Bound (1.5 * IQR):", upper_bound_m)

# For 'reading score'
reading_score = df['reading score']
mean_r, std_dev_r, median_r = reading_score.mean(), reading_score.std(), reading_score.median()
Q1_r, Q3_r = reading_score.quantile(0.25), reading_score.quantile(0.75)
IQR_r = Q3_r - Q1_r
lower_bound_r, upper_bound_r = Q1_r - 1.5 * IQR_r, Q3_r + 1.5 * IQR_r

# Print summary statistics for 'reading score'
print("\nReading Score:")
print("Mean:", mean_r)
print("Standard Deviation:", std_dev_r)
print("Median:", median_r)
print("Lower Bound (1.5 * IQR):", lower_bound_r)
print("Upper Bound (1.5 * IQR):", upper_bound_r)

# For 'writing score'
writing_score = df['writing score']
mean_w, std_dev_w, median_w = writing_score.mean(), writing_score.std(), writing_score.median()
Q1_w, Q3_w = writing_score.quantile(0.25), writing_score.quantile(0.75)
IQR_w = Q3_w - Q1_w
lower_bound_w, upper_bound_w = Q1_w - 1.5 * IQR_w, Q3_w + 1.5 * IQR_w

# Print summary statistics for 'writing score'
print("\nWriting Score:")
print("Mean:", mean_w)
print("Standard Deviation:", std_dev_w)
print("Median:", median_w)
print("Lower Bound (1.5 * IQR):", lower_bound_w)
print("Upper Bound (1.5 * IQR):", upper_bound_w)

# Step 2: Decide on outlier treatment technique

# Step 3: Apply outlier treatment
# For example, if we decide to trim outliers by removing observations outside the lower and upper bounds:
df = df[(df['math score'] >= lower_bound_m) & (df['math score'] <= upper_bound_m)]
df = df[(df['reading score'] >= lower_bound_r) & (df['reading score'] <= upper_bound_r)]
df = df[(df['writing score'] >= lower_bound_w) & (df['writing score'] <= upper_bound_w)]

# Alternatively, if we decide to winsorize the data:
# from scipy.stats.mstats import winsorize
# df['math score'] = winsorize(df['math score'], limits=[0.05, 0.05])
# df['reading score'] = winsorize(df['reading score'], limits=[0.05, 0.05])
# df['writing score'] = winsorize(df['writing score'], limits=[0.05, 0.05])

# You can apply similar techniques to other numeric variables in the DataFrame.

df.shape
df.head()

# Question 3

# Apply logarithmic transformation to 'math score'
df['math score_transformed'] = np.log(df['math score'])

# Plot the original and transformed distributions for comparison

plt.figure(figsize=(10, 5))

# Original distribution
plt.subplot(1, 2, 1)
plt.hist(df['math score'], bins=20, color='skyblue', edgecolor='black')
plt.title('Original Distribution (Math Score)')
plt.xlabel('Math Score')
plt.ylabel('Frequency')

# Transformed distribution
plt.subplot(1, 2, 2)
plt.hist(df['math score_transformed'], bins=20, color='lightgreen', edgecolor='black')
plt.title('Transformed Distribution (Logarithmic)')
plt.xlabel('Log(Math Score)')
plt.ylabel('Frequency')

plt.tight_layout()
plt.show()